var documenterSearchIndex = {"docs":
[{"location":"#fsid.jl-Documentation","page":"fsid.jl Documentation","title":"fsid.jl Documentation","text":"","category":"section"},{"location":"","page":"fsid.jl Documentation","title":"fsid.jl Documentation","text":"Modules = [fsid]\nOrder   = [:type, :function]","category":"page"},{"location":"#fsid.FRDC","page":"fsid.jl Documentation","title":"fsid.FRDC","text":"FRDC\n\nContinuous-time frequency response data object with fields:\n\nffdata: matrix of frequency response data. ffdata[i,:,:] is the frequency function matrix (sample of the rationl function) corresponding to sample i\nw: vector with angular frequencies rad/s\n\n\n\n\n\n","category":"type"},{"location":"#fsid.FRDC-Tuple{}","page":"fsid.jl Documentation","title":"fsid.FRDC","text":"FRDC()\n\nCreate empty FRDC object.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.FRDC-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S where T","page":"fsid.jl Documentation","title":"fsid.FRDC","text":"FRDC(ffdata::AbstractArray, w::AbstractVector)\n\nCreate FRDC object.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.FRDD","page":"fsid.jl Documentation","title":"fsid.FRDD","text":"FRDD\n\nDiscrete-time frequency response data object with fields:\n\nffdata: matrix of frequency response data. ffdata[i,:,:] is the frequency function matrix (sample of the rationl function) corresponding to sample i\nz: vector with the samples of the function argument where z[i] is argument for index i\n\n\n\n\n\n","category":"type"},{"location":"#fsid.FRDD-Tuple{}","page":"fsid.jl Documentation","title":"fsid.FRDD","text":"FRDD()\n\nCreate empty FRDD object.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.FRDD-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S where T","page":"fsid.jl Documentation","title":"fsid.FRDD","text":"FRDD(ffdata::AbstractArray, z::AbstractVector)\n\nCreate FRDD object.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.SS","page":"fsid.jl Documentation","title":"fsid.SS","text":"SS\n\nState-space object with fields:\n\na: system matrix n times n\nb: input matrix n times m\nc: output matrix r times n\nd: direct feedthrough matrix r times m\n\n\n\n\n\n","category":"type"},{"location":"#fsid.SS-Tuple{}","page":"fsid.jl Documentation","title":"fsid.SS","text":"SS()\n\nCreate empty SS object.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.SS-Union{Tuple{T}, NTuple{4,T}} where T","page":"fsid.jl Documentation","title":"fsid.SS","text":"SS(a::AbstractMatrix, b::AbstractMatrix, c::AbstractMatrix, d::AbstractMatrix)\n\nCreate SS object.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.SS-Union{Tuple{T}, Tuple{T,T,T}} where T","page":"fsid.jl Documentation","title":"fsid.SS","text":"SS(a::AbstractMatrix, b::AbstractMatrix, c::AbstractMatrix)\n\nCreate SS object without direct throughput.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.SS-Union{Tuple{T}, Tuple{T,T}} where T","page":"fsid.jl Documentation","title":"fsid.SS","text":"SS(a::AbstractMatrix, b::AbstractMatrix)\n\nCreate SS object without output and direct throughput.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.bilinear_c2d","page":"fsid.jl Documentation","title":"fsid.bilinear_c2d","text":"bilinear_c2d(sys::Tuple, T::Real = 1)\n\nCalculates the bilinear transformation C->D for ss-system sys.\n\nParameters:\n\nsys: tuple of system matrices (a, b, c, d)\nT: frequency scaling factor\n\nReturns:\n\na: system matrix\nb: intput matrix\nc: output matrix\nd: direct feedthrough matrix\n\n\n\n\n\n","category":"function"},{"location":"#fsid.bilinear_d2c","page":"fsid.jl Documentation","title":"fsid.bilinear_d2c","text":"bilinear_d2c(sys::Tuple, T::Real = 1)\n\nCalculates the bilinear transformation D->C for state-space system sys.\n\nParameters:\n\nsys: tuple of system matrices (a, b, c, d)\nT: frequency scaling factor\n\nReturns:\n\na: system matrix\nb: input matrix\nc: output matrix\nd: direct feedthrough matrix\n\n\n\n\n\n","category":"function"},{"location":"#fsid.cf2df-Tuple{AbstractArray{var\"#s68\",1} where var\"#s68\"<:Number,Real}","page":"fsid.jl Documentation","title":"fsid.cf2df","text":"cf2df(wc::AbstractVector{<:Number}, T::Real)\n\nCalculates the bilinear transformation frequency mapping C->D for frequency vector wc.\n\nParameters:\n\nwc: vector of frequencies\nT: frequency scaling factor\n\nReturns:\n\nwd: vector of transformed frequencies  \n\n\n\n\n\n","category":"method"},{"location":"#fsid.contype","page":"fsid.jl Documentation","title":"fsid.contype","text":"contype(type::Type{<:Real}, dtype = Float64)\ncontype(type::Type{<:Complex}, dtype = Float64)\n\nConvert type to default concrete type.\n\nParameters:\n\ntype: a concrete or abstract type\n\nReturns:\n\ndefault concrete type Float64\n\n\n\n\n\n","category":"function"},{"location":"#fsid.df2cf-Tuple{AbstractArray{var\"#s68\",1} where var\"#s68\"<:Number,Real}","page":"fsid.jl Documentation","title":"fsid.df2cf","text":"df2cf(wd::AbstractVector{<:Number}, T::Real)\n\nCalculates the bilinear transformation frequency mapping D->C for frequency vector wd.\n\nParameters:\n\nwd: vector of frequencies\nT: frequency scaling factor\n\nReturns:\n\nwc: vector of transformed frequencies  \n\n\n\n\n\n","category":"method"},{"location":"#fsid.estimate_bd-Tuple{AbstractArray{var\"#s25\",3} where var\"#s25\"<:Number,AbstractArray{var\"#s24\",1} where var\"#s24\"<:Number,AbstractArray{var\"#s23\",2} where var\"#s23\"<:Number,AbstractArray{var\"#s22\",2} where var\"#s22\"<:Number}","page":"fsid.jl Documentation","title":"fsid.estimate_bd","text":"estimate_bd(\n    ffdata::AbstractArray{<:Number, 3},\n    z::AbstractVector{<:Number},\n    a::AbstractMatrix{<:Number},\n    c::AbstractMatrix{<:Number};\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true,\n)\n\nEstimates the b and d matrices given a, c matrices and frequency function data ffdata.\n\nSolve the optimization problem\n\nmin_bd sum_i  d + c*inv(zi*I-a)*b - ffdatai ^2_F\n\nor if estimd == false\n\nmin_b sum_i  c*inv(zi*I-a)*b - ffdatai ^2_F\n\nif type = Real a real valued solution is calulated. If type = Complex the solution is complex valued\n\nParameters:\n\nffdata: frequency data packed in a matrix. ffdata[i,:,:] is the frequency function matrix corresponding to sample i\nz: vector with complex scalars\na: square matrix\nc: matrix\n\nOptional_\n\ntype: data type of model, either Real or Complex\nestimd: if set to false no d matrix is esimated and a zero d matrix is returned\n\nReturns:\n\nb: LS-optimal b matrix\nd: LS-optimal d matrix\n\n\n\n\n\n","category":"method"},{"location":"#fsid.estimate_cd-Tuple{AbstractArray{var\"#s39\",3} where var\"#s39\"<:Number,AbstractArray{var\"#s40\",1} where var\"#s40\"<:Number,AbstractArray{var\"#s41\",2} where var\"#s41\"<:Number,AbstractArray{var\"#s42\",2} where var\"#s42\"<:Number}","page":"fsid.jl Documentation","title":"fsid.estimate_cd","text":"estimate_cd(\n    ffdata::AbstractArray{<:Number, 3},\n    z::AbstractVector{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number};\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true,\n)\n\nEstimates the c and d matrices given a andbmatrices and frequency function dataffdata`.\n\nSolve the optimization problem\n\nmin_cd sum_i  d + c*inv(zi*I-a)*b - ffdatai ^2_F\n\nor if estimd == false\n\nmin_c sum_i  c*inv(zi*I-a)*b - ffdatai ^2_F\n\nif type = Real a real valued solution is calulated. If type = Complex the solution is complex valued\n\nParameters:\n\nffdata: frequency data packed in a matrix. ffdata[i,:,:] is the frequency function matrix corresponding to sample i\nz: vector with complex scalars\na: square matrix\nb: matrix\n\nOptional:\n\ntype: data type of model, either Real or Complex\nestimd: if set to false no d matrix is esimated and a zero d matrix is returned\n\nReturns :\n\nc: LS-optimal c matrix\nd: LS-optimal d matrix\n\n\n\n\n\n","category":"method"},{"location":"#fsid.fdestim_bd-Tuple{AbstractArray{var\"#s39\",1} where var\"#s39\"<:Number,AbstractArray{var\"#s38\",2} where var\"#s38\"<:Number,AbstractArray{var\"#s37\",2} where var\"#s37\"<:Number,AbstractArray{var\"#s36\",2} where var\"#s36\"<:Number,AbstractArray{var\"#s35\",2} where var\"#s35\"<:Number}","page":"fsid.jl Documentation","title":"fsid.fdestim_bd","text":"fdestim_bd(\n    z::AbstractVector{<:Number},\n    yd::AbstractMatrix{<:Number},\n    ud::AbstractMatrix{<:Number},\n    a::AbstractMatrix{<:Number},\n    c::AbstractMatrix{<:Number};\n    estTrans::Bool = false,\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true\n)\n\nEstimate b and d matrices (and optionally xt) given yd, ud, a and c matrices.\n\nCalulates the b and d matrices (and optimally xt) for a linear dynamic system in state-space form given the a and c matrices and samples of frequency domain function data. It solves  if estimd = true and estTrans = true\n\nmin_bdxt sum_i  (d 0 + c*inv(zi*I-a)*b xt)udi zi  - ffdatai ^2_F\n\nif estimd = false and estTrans = true\n\nmin_bxt sum_i  (c*inv(zi*I-a)*b xt)udi wi  - ffdatai ^2_F\n\nif estimd = true and estTrans = false\n\nmin_bd sum_i   (d+ c*inv(zi*I-a)*b)udi  - ffdatai ^2_F\n\nif estimd = false and estTrans = false\n\nmin_b sum_i  (c*inv(zi*I-a)*b)udi  - ffdatai ^2_F\n\nif type = Real a real valued solution is calulated. if type = Complex  the solution is complex valued\n\nParameters:\n\nz: vector with the samples of the function argument where z[i] is argument for index i\nyd: output frequency data yd[i,:]\nud: input frequency data ud[widx,:]\na: system matrix\nc: output matrix\n\nOptional:\n\nestTrans: if set to true also an xt vector will be estimated capturing the transient effect\ntype: data type of model, either Real or Complex\nestimd: if set to false no d matrix is esimated and a zero d matrix is returned\n\nReturns:\n\nb: the LS-optimal b matrix\nd: LS-optimal d matrix  zeros matrix if estimd = false\nxt: LS-optimal xt vector if estTrans = true\n\n\n\n\n\n","category":"method"},{"location":"#fsid.fdestim_cd","page":"fsid.jl Documentation","title":"fsid.fdestim_cd","text":"fdestim_cd(\n    z::AbstractVector{<:Number},\n    yd::AbstractArray{<:Number},\n    ud::AbstractArray{<:Number},\n    a::AbstractArray{<:Number},\n    b::AbstractArray{<:Number},\n    xt::Union{AbstractVector{<:Number}, Number} = 0;\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true\n)\n\nEstimate c and d matrices given z, yd, ud and a, c, and (optionally xt) matrices.\n\nCalulates the c and d matrices for a linear dynamic system on state-space form given the a and b matrices and samples of rational function data. It solves if estimd = true\n\nmin_cd sum_i  (d 0 + c*inv(zi*I-a)*b xt)udi zi  - ffdatai ^2_F\n\nif estimd = false\n\nmin_c sum_i  (c*inv(zi*I-a)*b xt)udi wi  - ffdatai ^2_F\n\nif type = Real a real valued solution is calulated. if type = Complex the solution is complex valued\n\nParameters:\n\nffdata: data packed in a matrix. ffdata[i,:,:] is the frequency function matrix (sample of the rationl function) corresponding to sample i\nw: vector with the rational function arguments. w[i] is the function arguemnt for sample i\na: matrix\nb: matrix\n\nOptional:\n\nxt: vector\ntype: data type of model either Real or Complex\nestimd: if set to false no d matrix is esimated and a zero d matrix is returned\n\nReturns :\n\nc: LS-optimal c matrix\nd: LS-optimal d matrix\n\n\n\n\n\n","category":"function"},{"location":"#fsid.fdsid-Tuple{Tuple,Integer,Integer}","page":"fsid.jl Documentation","title":"fsid.fdsid","text":"function fdsid(\n    fddata::Tuple,\n    n::Integer,\n    q::Integer;\n    estTrans::Bool = true,\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true,\n    CT::Bool = false,\n    T::Real = 1\n)\n\nEstimate a DT or CT state-space model from I/O frequency data.\n\nDetermines the (a,b,c,d,xt) parametrers such that (DT case)\n\nsum_i    yi - d*ui  + c*inv(zi*eye(n)-a)*b  xt* ui  zi^_F\n\nis small where z[i] = exp(im*w[i]) and CT Case\n\nsum_i     yi - d*ui  + c*inv(im*wi*eye(n)-a)*b* ui  ^2_F\n\nParameters:\n\nfddata: a tuple with elements \nfddata[0] = w: a vector of frequencies in radians/sample (rad/s in CT case)\nfddata[1] = y: a matrix of the output transform data where y[i,:] is the DFT of the time domain output signal corresponding to frequency w[i]\nfddata[2] = u: a matrix of the input transform data where u[i,:] is the DFT of the time domain input signal corresponding to frequency w[i]\nn: the model order of the ss-model\nq: the numer of block rows used in the intermediate matrix. Must satisfy q > n\n\nOptional:\n\nestTrans: if true, a compensation for the transient term will be estimated (default)\ntype:\nif type = Real a real valued solution (a, b, c, d) is returned.\nif type = Complex a complex valued solution is returned.\nestimd: if set to false no d matrix is esimated and a zero d matrix is returned\nCT: if true a CT model is estimated and estTrans is forced false\nT: a frequency scaling factor for the bilinear transformation used when CT = true.  Default is 1. If CT = false parameter T is disregarded\n\nReturns:\n\na: the estimated a matrix\nb: the estimated b matrix\nc: the estimated c matrix\nd: the estimated d matrix (or zero matrix if estimd = false)\nxt: vector of the transient compensation\ns: a vector of the singular values   \n\n\n\n\n\n","category":"method"},{"location":"#fsid.fdsim","page":"fsid.jl Documentation","title":"fsid.fdsim","text":"function fdsim(\n    sys::Tuple,\n    u::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number},\n    xt::AbstractMatrix{<:Number} = Matrix{Float64}(undef, 0, 0)\n)\n\nCalculates the output given input and state-space model in Fourier domain\n\nxi = inv(zi*I-a)*B xt*ui zi\n\nyi = d*ui + c*xi\n\nParameters:\n\nsys: typle sys = (a, b, c, d) or sys = (a, b, c) where a is a  square matrix of size (n,n), b is  a matrix of size (n, m), c is a matrix of size (p, n) and (optionally) d is a matrix of size (p, m).\nu: an array of input vectors such that u[i,:] is the input vector of size m at sample index i. The array has size (N, m)\nz: vector with the samples of the frequency function argument\n\nxt: transient vector of size n, Default value is the zero vector. \n\nReturns:\n\ny: the resulting output sequence of size (N,p)\nx: the resulting state sequence of size (N,p)\n\n\n\n\n\n","category":"function"},{"location":"#fsid.ffdata2fddata-Tuple{AbstractArray{var\"#s64\",3} where var\"#s64\"<:Number,AbstractArray{var\"#s63\",1} where var\"#s63\"<:Number}","page":"fsid.jl Documentation","title":"fsid.ffdata2fddata","text":"ffdata2fddata(ffdata::AbstractArray{<:Number, 3}, z::AbstractVector{<:Number})\n\nConverts ffdata to fddata.\n\nConverts frequency function data ffdata to input/output data format fddata.\n\nParameters:\n\nffdata: frequency function data in the format such that ffdata[i,:,:] corresponds to the frequency function matrix of size (p,m) at frequency index i corresponding to function argument z[i] at a total number of samples nz\nz: array with the corresponding frequency function argument of size nz\n\nReturns:\n\nu: Fourier transform of input of size (m*nz, m)\ny: Fourier transform of output of size (m*nz, p)\nzn: frequency function argument vector of length m*nw\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ffsid-Tuple{AbstractArray{var\"#s49\",1} where var\"#s49\"<:Number,AbstractArray{var\"#s48\",3} where var\"#s48\"<:Number,Integer,Integer}","page":"fsid.jl Documentation","title":"fsid.ffsid","text":"function ffsid(\n    w::AbstractVector{<:Number},\n    ffdata::AbstractArray{<:Number, 3},\n    n::Integer,\n    q::Integer;\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true,\n    CT::Bool = false,\n    T::Real = 1\n)\n\nEstimate a state-space model (a, b, c, d) from frequency function data.\n\nParameters:\n\nw: vector of frequencies in rad/sample [-pi,pi] or [0, 2pi]. if CT = true unit in radians/s (-inf, +inf)\nffdata: matrix of frequency function data. ffdata[i,:,:] is the frequency response matrix at frequency w[i]\nn: the model order of the ss-model (a, b, c, d), i.e. a is a size (n x n) matrix\nq: the numer of block rows used in the intermediate matrix. Must satisfy q > n\n\nOptional:\n\ntype:\nif type = Real a real valued solution (a, b, c, d) is returned\nif type = Complex a complex valued solution (a,b,c,d) is returned\nestimd: if set to False no d matrix is esimated and a zero d matrix is returned\nCT:\nif set to true a continuous time (CT) model is esimated\nif set to false a discrete time (DT) model is esimated (default)\nT: a frequency scaling factor for the bilinear transformation used when CT = true. Default is 1. If CT = false parameter T is disregarded\n\nReturns:\n\na: the estimated a matrix\nb: the estimated b matrix\nc: the estimated c matrix\nd: the estimated d matrix (or zero matrix if estimd = false)\ns: a vector of the singular values   \n\n\n\n\n\n","category":"method"},{"location":"#fsid.fresp","page":"fsid.jl Documentation","title":"fsid.fresp","text":"function fresp(\n    z::AbstractVector{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    c::AbstractMatrix{<:Number},\n    d::AbstractMatrix{<:Number},\n    noWarning::Bool = true\n)\n\nFrequency response of ss-model (a,b,c,d) a rational matrix function\n\nfrespi = d+c*inv(zi*I-a)*b\n\nfresp[i,:,:] is the function value of the rational matrix function evaluated at z[i]\n\nParameters:\n\nz: vector with samples of the function argument\na: matrix\nb: matrix\nc: matrix\nd: matrix\nnoWarning: information message is suppressed if set to true\n\nReturns:\n\nfrsp: frequency response\n\n\n\n\n\n","category":"function"},{"location":"#fsid.fresp_fast!-Tuple{AbstractArray{var\"#s60\",3} where var\"#s60\"<:Number,AbstractArray{var\"#s59\",1} where var\"#s59\"<:Number,AbstractArray{var\"#s58\",2} where var\"#s58\"<:Number,AbstractArray{var\"#s57\",2} where var\"#s57\"<:Number,AbstractArray{var\"#s56\",2} where var\"#s56\"<:Number,AbstractArray{var\"#s55\",2} where var\"#s55\"<:Number,LinearAlgebra.Eigen}","page":"fsid.jl Documentation","title":"fsid.fresp_fast!","text":"function fresp_fast!(\n   frsp::AbstractArray{<:Number, 3},\n    z::AbstractVector{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    c::AbstractMatrix{<:Number},\n    d::AbstractMatrix{<:Number},\n    eig::Eigen\n)\n\nFrequency response of ss-model (a, b, c, d) (fast version)\n\nfrespi = d+c*inv(I*zi-a)*b\n\n\n\n\n\n","category":"method"},{"location":"#fsid.fresp_slow!-Tuple{AbstractArray{var\"#s61\",3} where var\"#s61\"<:Number,AbstractArray{var\"#s60\",1} where var\"#s60\"<:Number,AbstractArray{var\"#s59\",2} where var\"#s59\"<:Number,AbstractArray{var\"#s58\",2} where var\"#s58\"<:Number,AbstractArray{var\"#s57\",2} where var\"#s57\"<:Number,AbstractArray{var\"#s56\",2} where var\"#s56\"<:Number}","page":"fsid.jl Documentation","title":"fsid.fresp_slow!","text":"function fresp_slow!(\n    frsp::AbstractArray{<:Number, 3},\n    z::AbstractVector{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    c::AbstractMatrix{<:Number},\n    d::AbstractMatrix{<:Number}\n)\n\nFrequency response of state-space model (a, b, c, d) (slow version) calulated as\n\nfrespi = d + c * (I*zi-a)^-1 * b\n\n\n\n\n\n","category":"method"},{"location":"#fsid.gfdsid-Tuple{Tuple,Integer,Integer}","page":"fsid.jl Documentation","title":"fsid.gfdsid","text":"function gfdsid(\n    fddata::Tuple,\n    n::Integer,\n    q::Integer;\n    estTrans::Bool = true,\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true\n)\n\nEstimate a state-space model from I/O frequency data\n\nDetermines the (a, b, c, d, xt) parameters such that\n\nsum_i  yi - d*ui  + c*inv(zi*eye(n)-a)*b  xt* ui  zi ^2_F\n\nis minimized.\n\nIf estrTrans = false the following problem is solved\n\nsum_i  yi - d*ui  + c*inv(zi*eye(n)-a)*b * ui  ^2_F\n\nis minimized.\n\nParameters:\n\nfddata: a tuple with elements \nfddata[0] = z: a vector of complex scalars,\nfddata[1] = y: a matrix of the output frequency data where y[i,:] corresponds to z[i]\nfddata[2] = u: a matrix of the input frrequency data where u[i,:] corresponding to z[i]\nn: the model order of the ss-model\nq: the numer of block rows used in the intermediate matrix. Must satisfy q > n\n\nOptional:\n\nestTrans: if true, a compensation for the transient term will be estimated (default)\ntype:\nif type = Real a real valued solution (a, b, c, d) is returned.\nif type = Complex a complex valued solution is returned.\nestimd: if set to 'false' no d matrix is esimated and a zero d matrix is returned\n\nReturns:\n\na: the estimated a matrix\nb: the estimated b matrix\nc: the estimated c matrix\nd: the estimated d matrix (or zero matrix if estimd = false)\nx: vector of the transient compensation\ns: a vector of the singular values   \n\n\n\n\n\n","category":"method"},{"location":"#fsid.gffsid-Tuple{AbstractArray{var\"#s47\",1} where var\"#s47\"<:Number,AbstractArray{var\"#s46\",3} where var\"#s46\"<:Number,Integer,Integer}","page":"fsid.jl Documentation","title":"fsid.gffsid","text":"function gffsid(\n    z::AbstractVector{<:Number},\n    ffdata::AbstractArray{<:Number, 3},\n    n::Integer,\n    q::Integer;\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real,\n    estimd::Bool = true\n)\n\nEstimate a state-space model (a, b, c, d) from general frequency function data by mininizing the Frobenius norm \n\nsum_i  ffdatai - d - c*inv(zi*eye(n)-a)*b ^2_F\n\nParameters:\n\nz: vector of complex numbers\nffdata: matrix of frequency function data. ffdata[i,:,:] is the frequency response matrix at complex point z[i]\nn: the model order of the ss-model (a, b, c, d), i.e. a is a size (n x n) matrix\nq: the numer of block rows used in the intermediate matrix. Must satisfy q > n\n\nOptional:\n\ntype:\nif type = Real a real valued solution (a, b, c, d) is returned\nif type = Complex a complex valued solution is returned\nestimd: if set to false no d matrix is esimated and a zero d matrix is returned\n\nReturns:\n\na: the estimated a matrix\nb: the estimated b matrix\nc: the estimated c matrix\nd: the estimated d matrix (or zero matrix if estimd = false)\ns: a vector of the singular values   \n\n\n\n\n\n","category":"method"},{"location":"#fsid.lsim","page":"fsid.jl Documentation","title":"fsid.lsim","text":"function lsim(\n    sys::Tuple,\n    u::AbstractMatrix{<:Number},\n    x0::Union{AbstractVector{<:Number}, Number} = 0;\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real\n)\n\nCalculates the time-domain output given input sequence and state-space model sys = (a, b, c, d)\n\nxi+1 = a*xi) + b*ui\n\nyi =  c*xi) + d*ui\n\nParameters:\n\nsys: a typle sys = (a, b, c, d) or sys = (a, b, c) where a is a square matrix of size (n,n), b is a matrix of size (n,m), c is a matrix of size (p,n) and (optionally) d is a matrix of size (p, m)`\nu: an array of input vectors such that u[i,:] is the input vector of size m at time index i. The array has size (N, m)\n\nOptional:\n\nx0: intial vector of size n, i.e. x[0,:] = x0. Default value is the zero vector\n\nReturns:\n\ny: the resulting output sequence of size (N, p)\nx: the resulting state sequence of size (N, n)\n\n\n\n\n\n","category":"function"},{"location":"#fsid.lsim-2","page":"fsid.jl Documentation","title":"fsid.lsim","text":"function lsim(\n    sys::Tuple,\n    u::AbstractMatrix{<:Number},\n    x0::Union{AbstractVector{<:Number}, Number} = 0;\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real\n)\n\nCalculates the time-domain output given input sequence and state-space model sys = (a, b, c, d)\n\nxi+1 = a*xi) + b*ui\n\nyi =  c*xi) + d*ui\n\nParameters:\n\nsys: a typle sys = (a, b, c, d) or sys = (a, b, c) where a is a square matrix of size (n,n), b is a matrix of size (n,m), c is a matrix of size (p,n) and (optionally) d is a matrix of size (p,m)\nu: an array of input vectors such that u[i,:] is the input vector of size m at time index i. The array has size (N,m).\n\nOptional:\n\nx0: intial vector of size n, i.e. x[0,:] = x0. Default value is the zero vector\n\nReturns:\n\ny: the resulting output sequence of size (N, p)\nx: the resulting state sequence of size (N, n)\n\n\n\n\n\n","category":"function"},{"location":"#fsid.ltifd","page":"fsid.jl Documentation","title":"fsid.ltifd","text":"function ltifd(\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    u::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number},\n    noWarning::Bool = true\n)\n\nCalculates the frequency kernel with input u\n\nfkern i = inv(zi*I - a)*b*ui \n\nParameters:\n\na: matrix\nb: matrix\nu: input vectors\nz: vector with samples of the function argument\nnoWarning: if true suppress information message\n\nReturns:\n\nfkern: frequency kernel\n\n\n\n\n\n","category":"function"},{"location":"#fsid.ltifd_fast!-Tuple{AbstractArray{var\"#s61\",2} where var\"#s61\"<:Number,AbstractArray{var\"#s60\",2} where var\"#s60\"<:Number,AbstractArray{var\"#s59\",2} where var\"#s59\"<:Number,AbstractArray{var\"#s58\",2} where var\"#s58\"<:Number,AbstractArray{var\"#s57\",1} where var\"#s57\"<:Number,LinearAlgebra.Eigen}","page":"fsid.jl Documentation","title":"fsid.ltifd_fast!","text":"function ltifd_fast!(\n    fkern::AbstractMatrix{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    u::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number},\n    eig::Eigen\n)\n\nCalculates the frequency kernel with input u in place (fast version)\n\nfkern i = inv(zi*I - a)*b*ui \n\nParameters:\n\nfkern: frequency kernel\na: matrix\nb: matrix\nu: matrix with input vectors\nz: vector with the frequecy data\neig: eigendecomposition of a\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltifd_slow!-Tuple{AbstractArray{var\"#s34\",2} where var\"#s34\"<:Number,AbstractArray{var\"#s33\",2} where var\"#s33\"<:Number,AbstractArray{var\"#s30\",2} where var\"#s30\"<:Number,AbstractArray{var\"#s29\",2} where var\"#s29\"<:Number,AbstractArray{var\"#s28\",1} where var\"#s28\"<:Number}","page":"fsid.jl Documentation","title":"fsid.ltifd_slow!","text":"function ltifd_slow!(\n    fkern::AbstractMatrix{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    u::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number}\n)\n\nCalculates the frequency kernel with input u in place (slow version)\n\nfkern i = inv(zi*I - a)*b*ui \n\nParameters:\n\nfkern: frequency kernel\na: matrix\nb: matrix\nu: matrix with input vectors\nz: vector with the frequecy data\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltifd_slow!-Tuple{AbstractArray{var\"#s62\",2} where var\"#s62\"<:Number,AbstractArray{var\"#s61\",2} where var\"#s61\"<:Number,AbstractArray{var\"#s60\",2} where var\"#s60\"<:Number,AbstractArray{var\"#s59\",2} where var\"#s59\"<:Number,AbstractArray{var\"#s58\",1} where var\"#s58\"<:Number}","page":"fsid.jl Documentation","title":"fsid.ltifd_slow!","text":"function ltifd_slow!(\n    fkern::AbstractMatrix{<:Number},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    u::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number}\n)\n\nCalculates the frequency kernel with input u in place (slow version)\n\nfkern i = inv(zi*I - a)*b*ui \n\nParameters:\n\nfkern: frequency kernel\na: matrix\nb: matrix\nu: matrix with input vectors\nz: vector with the frequecy data\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltifr","page":"fsid.jl Documentation","title":"fsid.ltifr","text":"function ltifr(\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number},\n    noWarning::Bool = true    \n)\n\nCalculates the frequency kernel\n\nfkerni = inv(zi*I-a)*b\n\nParameters:\n\na: matrix\nb: matrix\nz: vector with the samples of the function argument\nnoWarning: if true suppress information message\n\nReturns:\n\nfkern: frequency response \n\n\n\n\n\n","category":"function"},{"location":"#fsid.ltifr_fast!-Tuple{AbstractArray{var\"#s34\",3} where var\"#s34\"<:Number,AbstractArray{var\"#s33\",2} where var\"#s33\"<:Number,AbstractArray{var\"#s30\",2} where var\"#s30\"<:Number,AbstractArray{var\"#s29\",1} where var\"#s29\"<:Number,LinearAlgebra.Eigen}","page":"fsid.jl Documentation","title":"fsid.ltifr_fast!","text":"function ltifr_fast!(\n    fkern::AbstractArray{<:Number, 3},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number},\n    eig::Eigen\n)\n\nCalculates the frequency kernel in place (fast version)\n\nfkerni = inv(zi*I-a)*b\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltifr_fast!-Tuple{AbstractArray{var\"#s62\",3} where var\"#s62\"<:Number,AbstractArray{var\"#s61\",2} where var\"#s61\"<:Number,AbstractArray{var\"#s60\",2} where var\"#s60\"<:Number,AbstractArray{var\"#s59\",1} where var\"#s59\"<:Number,LinearAlgebra.Eigen}","page":"fsid.jl Documentation","title":"fsid.ltifr_fast!","text":"function ltifr_fast!(\n    fkern::AbstractArray{<:Number, 3},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number},\n    eig::Eigen\n)\n\nCalculates the frequency kernel in place (fast version)\n\nfkerni = inv(zi*I-a)*b (slow version)\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltifr_slow!-Tuple{AbstractArray{var\"#s34\",3} where var\"#s34\"<:Number,AbstractArray{var\"#s33\",2} where var\"#s33\"<:Number,AbstractArray{var\"#s30\",2} where var\"#s30\"<:Number,AbstractArray{var\"#s29\",1} where var\"#s29\"<:Number}","page":"fsid.jl Documentation","title":"fsid.ltifr_slow!","text":"function ltifr_slow!(\n    fkern::AbstractArray{<:Number, 3},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number}\n)\n\nCalculates the frequency kernel in place as (slow version)\n\nfkerni = inv(zi*I-a)*b\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltifr_slow!-Tuple{AbstractArray{var\"#s62\",3} where var\"#s62\"<:Number,AbstractArray{var\"#s61\",2} where var\"#s61\"<:Number,AbstractArray{var\"#s60\",2} where var\"#s60\"<:Number,AbstractArray{var\"#s59\",1} where var\"#s59\"<:Number}","page":"fsid.jl Documentation","title":"fsid.ltifr_slow!","text":"function ltifr_slow!(\n    fkern::AbstractArray{<:Number, 3},\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    z::AbstractVector{<:Number}\n)\n\nCalculates the frequency kernel in place as\n\nfkerni = inv(zi*I-a)*b (slow version)\n\n\n\n\n\n","category":"method"},{"location":"#fsid.ltitr","page":"fsid.jl Documentation","title":"fsid.ltitr","text":"function ltitr(\n    a::AbstractMatrix{<:Number},\n    b::AbstractMatrix{<:Number},\n    u::AbstractMatrix{<:Number},\n    x0::Union{AbstractVector{<:Number}, Number} = 0;\n    type::Union{Type{<:Real}, Type{<:Complex}} = Real\n)\n\nCalculates the time domain input to state respone.\n\nCalculates the time domain state response\n\nxi+1 = a*xi) + b*ui\n\nParmeters:\n\na: a square matrix of size (n, n)\nb: a matrix of size (n, m)\nu: an array of input vectors such that u[i,:] is the input vector of size m at time index i. The array has size (N, m)\nx0: intial vector of size n, i.e. x[0,:] = x0. Default value is the zero vector\n\nReturns:\n\nx: the resulting state-sequence of size (N, n)\nx[k,:]: is the state at sample k\n\n\n\n\n\n","category":"function"},{"location":"#fsid.matrix_chain_order-Tuple{Any}","page":"fsid.jl Documentation","title":"fsid.matrix_chain_order","text":"matrix_chain_order(p)\n\nReference: Cormen, \"Introduction to Algorithms\", Chapter 15.2, p. 370-378\n\n\n\n\n\n","category":"method"},{"location":"#fsid.multidot-Tuple","page":"fsid.jl Documentation","title":"fsid.multidot","text":"multidot(mats...)\n\nFast multiplication of multiple matrices, i.e. optimal order. Provide matrices in order of multiplication.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.optimal_print-Tuple{Any,Any,Any}","page":"fsid.jl Documentation","title":"fsid.optimal_print","text":"optimal_print(s, i, j)\n\nHelper function.\n\n\n\n\n\n","category":"method"},{"location":"#fsid.transpose_ffdata-Tuple{AbstractArray{var\"#s45\",3} where var\"#s45\"<:Number}","page":"fsid.jl Documentation","title":"fsid.transpose_ffdata","text":"transpose_ffdata(ffdata::AbstractArray{<:Number, 3})\n\nTransposes ffdata (changes inputs and outputs).\n\n\n\n\n\n","category":"method"}]
}
