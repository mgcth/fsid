<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>fsid.jl Documentation · Documentation for Julia version of fsid</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Documentation for Julia version of fsid</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>fsid.jl Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>fsid.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>fsid.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mgcth/fsid/blob/master/julia/doc/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="fsid.jl-Documentation"><a class="docs-heading-anchor" href="#fsid.jl-Documentation">fsid.jl Documentation</a><a id="fsid.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#fsid.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="fsid.FRDC" href="#fsid.FRDC"><code>fsid.FRDC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FRDC</code></pre><p>Continuous-time frequency response data object with fields:</p><ul><li><code>ffdata</code>: matrix of frequency response data. <code>ffdata[i,:,:]</code> is the frequency function matrix (sample of the rationl function) corresponding to sample <code>i</code></li><li><code>w</code>: vector with angular frequencies <code>rad/s</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.FRDC-Tuple{}" href="#fsid.FRDC-Tuple{}"><code>fsid.FRDC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FRDC()</code></pre><p>Create empty FRDC object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.FRDC-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S where T" href="#fsid.FRDC-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S where T"><code>fsid.FRDC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FRDC(ffdata::AbstractArray, w::AbstractVector)</code></pre><p>Create FRDC object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.FRDD" href="#fsid.FRDD"><code>fsid.FRDD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FRDD</code></pre><p>Discrete-time frequency response data object with fields:</p><ul><li><code>ffdata</code>: matrix of frequency response data. <code>ffdata[i,:,:]</code> is the frequency function matrix (sample of the rationl function) corresponding to sample <code>i</code></li><li><code>z</code>: vector with the samples of the function argument where <code>z[i]</code> is argument for index <code>i</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.FRDD-Tuple{}" href="#fsid.FRDD-Tuple{}"><code>fsid.FRDD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FRDD()</code></pre><p>Create empty FRDD object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.FRDD-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S where T" href="#fsid.FRDD-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S where T"><code>fsid.FRDD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FRDD(ffdata::AbstractArray, z::AbstractVector)</code></pre><p>Create FRDD object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.SS" href="#fsid.SS"><code>fsid.SS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SS</code></pre><p>State-space object with fields:</p><ul><li><code>a</code>: system matrix <span>$n \times n$</span></li><li><code>b</code>: input matrix <span>$n \times m$</span></li><li><code>c</code>: output matrix <span>$r \times n$</span></li><li><code>d</code>: direct feedthrough matrix <span>$r \times m$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.SS-Tuple{}" href="#fsid.SS-Tuple{}"><code>fsid.SS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SS()</code></pre><p>Create empty SS object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.SS-Union{Tuple{T}, NTuple{4,T}} where T" href="#fsid.SS-Union{Tuple{T}, NTuple{4,T}} where T"><code>fsid.SS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SS(a::AbstractMatrix, b::AbstractMatrix, c::AbstractMatrix, d::AbstractMatrix)</code></pre><p>Create SS object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.SS-Union{Tuple{T}, Tuple{T,T,T}} where T" href="#fsid.SS-Union{Tuple{T}, Tuple{T,T,T}} where T"><code>fsid.SS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SS(a::AbstractMatrix, b::AbstractMatrix, c::AbstractMatrix)</code></pre><p>Create SS object without direct throughput.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.SS-Union{Tuple{T}, Tuple{T,T}} where T" href="#fsid.SS-Union{Tuple{T}, Tuple{T,T}} where T"><code>fsid.SS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SS(a::AbstractMatrix, b::AbstractMatrix)</code></pre><p>Create SS object without output and direct throughput.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/types.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.bilinear_c2d" href="#fsid.bilinear_c2d"><code>fsid.bilinear_c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bilinear_c2d(sys::Tuple, T::Real = 1)</code></pre><p>Calculates the bilinear transformation C-&gt;D for ss-system <code>sys</code>.</p><p>Parameters:</p><ul><li><code>sys</code>: tuple of system matrices <code>(a, b, c, d)</code></li><li><code>T</code>: frequency scaling factor</li></ul><p>Returns:</p><ul><li><code>a</code>: system matrix</li><li><code>b</code>: intput matrix</li><li><code>c</code>: output matrix</li><li><code>d</code>: direct feedthrough matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L594-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.bilinear_d2c" href="#fsid.bilinear_d2c"><code>fsid.bilinear_d2c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bilinear_d2c(sys::Tuple, T::Real = 1)</code></pre><p>Calculates the bilinear transformation D-&gt;C for state-space system <code>sys</code>.</p><p>Parameters:</p><ul><li><code>sys</code>: tuple of system matrices <code>(a, b, c, d)</code></li><li><code>T</code>: frequency scaling factor</li></ul><p>Returns:</p><ul><li><code>a</code>: system matrix</li><li><code>b</code>: input matrix</li><li><code>c</code>: output matrix</li><li><code>d</code>: direct feedthrough matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L567-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.cf2df-Tuple{AbstractArray{var&quot;#s68&quot;,1} where var&quot;#s68&quot;&lt;:Number,Real}" href="#fsid.cf2df-Tuple{AbstractArray{var&quot;#s68&quot;,1} where var&quot;#s68&quot;&lt;:Number,Real}"><code>fsid.cf2df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cf2df(wc::AbstractVector{&lt;:Number}, T::Real)</code></pre><p>Calculates the bilinear transformation frequency mapping C-&gt;D for frequency vector <code>wc</code>.</p><p>Parameters:</p><ul><li><code>wc</code>: vector of frequencies</li><li><code>T</code>: frequency scaling factor</li></ul><p>Returns:</p><ul><li><code>wd</code>: vector of transformed frequencies  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L621-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.contype" href="#fsid.contype"><code>fsid.contype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contype(type::Type{&lt;:Real}, dtype = Float64)
contype(type::Type{&lt;:Complex}, dtype = Float64)</code></pre><p>Convert type to default concrete type.</p><p>Parameters:</p><ul><li><code>type</code>: a concrete or abstract type</li></ul><p>Returns:</p><ul><li>default concrete type <code>Float64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L649-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.df2cf-Tuple{AbstractArray{var&quot;#s68&quot;,1} where var&quot;#s68&quot;&lt;:Number,Real}" href="#fsid.df2cf-Tuple{AbstractArray{var&quot;#s68&quot;,1} where var&quot;#s68&quot;&lt;:Number,Real}"><code>fsid.df2cf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">df2cf(wd::AbstractVector{&lt;:Number}, T::Real)</code></pre><p>Calculates the bilinear transformation frequency mapping D-&gt;C for frequency vector <code>wd</code>.</p><p>Parameters:</p><ul><li><code>wd</code>: vector of frequencies</li><li><code>T</code>: frequency scaling factor</li></ul><p>Returns:</p><ul><li><code>wc</code>: vector of transformed frequencies  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L635-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.estimate_bd-Tuple{AbstractArray{var&quot;#s25&quot;,3} where var&quot;#s25&quot;&lt;:Number,AbstractArray{var&quot;#s24&quot;,1} where var&quot;#s24&quot;&lt;:Number,AbstractArray{var&quot;#s23&quot;,2} where var&quot;#s23&quot;&lt;:Number,AbstractArray{var&quot;#s22&quot;,2} where var&quot;#s22&quot;&lt;:Number}" href="#fsid.estimate_bd-Tuple{AbstractArray{var&quot;#s25&quot;,3} where var&quot;#s25&quot;&lt;:Number,AbstractArray{var&quot;#s24&quot;,1} where var&quot;#s24&quot;&lt;:Number,AbstractArray{var&quot;#s23&quot;,2} where var&quot;#s23&quot;&lt;:Number,AbstractArray{var&quot;#s22&quot;,2} where var&quot;#s22&quot;&lt;:Number}"><code>fsid.estimate_bd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimate_bd(
    ffdata::AbstractArray{&lt;:Number, 3},
    z::AbstractVector{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    c::AbstractMatrix{&lt;:Number};
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true,
)</code></pre><p>Estimates the <code>b</code> and <code>d</code> matrices given <code>a</code>, <code>c</code> matrices and frequency function data <code>ffdata</code>.</p><p>Solve the optimization problem</p><p><span>$\min_{b,d} \sum_i \| d + c*inv(z[i]*I-a)*b - ffdata[i,:,:] \|^2_F$</span></p><p>or if <code>estimd == false</code></p><p><span>$\min_{b} \sum_i \| c*inv(z[i]*I-a)*b - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>type = Real</code> a real valued solution is calulated. If <code>type = Complex</code> the solution is complex valued</p><p>Parameters:</p><ul><li><code>ffdata</code>: frequency data packed in a matrix. <code>ffdata[i,:,:]</code> is the frequency function matrix corresponding to sample <code>i</code></li><li><code>z</code>: vector with complex scalars</li><li><code>a</code>: square matrix</li><li><code>c</code>: matrix</li></ul><p><em>Optional_</em></p><ul><li><code>type</code>: data type of model, either <code>Real</code> or <code>Complex</code></li><li><code>estimd</code>: if set to false no <code>d</code> matrix is esimated and a zero <code>d</code> matrix is returned</li></ul><p>Returns:</p><ul><li><code>b</code>: LS-optimal <code>b</code> matrix</li><li><code>d</code>: LS-optimal <code>d</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/estimate_c.jl#L68-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.estimate_cd-Tuple{AbstractArray{var&quot;#s39&quot;,3} where var&quot;#s39&quot;&lt;:Number,AbstractArray{var&quot;#s40&quot;,1} where var&quot;#s40&quot;&lt;:Number,AbstractArray{var&quot;#s41&quot;,2} where var&quot;#s41&quot;&lt;:Number,AbstractArray{var&quot;#s42&quot;,2} where var&quot;#s42&quot;&lt;:Number}" href="#fsid.estimate_cd-Tuple{AbstractArray{var&quot;#s39&quot;,3} where var&quot;#s39&quot;&lt;:Number,AbstractArray{var&quot;#s40&quot;,1} where var&quot;#s40&quot;&lt;:Number,AbstractArray{var&quot;#s41&quot;,2} where var&quot;#s41&quot;&lt;:Number,AbstractArray{var&quot;#s42&quot;,2} where var&quot;#s42&quot;&lt;:Number}"><code>fsid.estimate_cd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimate_cd(
    ffdata::AbstractArray{&lt;:Number, 3},
    z::AbstractVector{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number};
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true,
)</code></pre><p>Estimates the <code>c</code> and <code>d</code> matrices given <code>a and</code>b<code>matrices and frequency function data</code>ffdata`.</p><p>Solve the optimization problem</p><p><span>$\min_{c,d} \sum_i \| d + c*inv(z[i]*I-a)*b - ffdata[i,:,:] \|^2_F$</span></p><p>or if <code>estimd == false</code></p><p><span>$\min_{c} \sum_i \| c*inv(z[i]*I-a)*b - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>type = Real</code> a real valued solution is calulated. If <code>type = Complex</code> the solution is complex valued</p><p>Parameters:</p><ul><li><code>ffdata</code>: frequency data packed in a matrix. <code>ffdata[i,:,:]</code> is the frequency function matrix corresponding to sample <code>i</code></li><li><code>z</code>: vector with complex scalars</li><li><code>a</code>: square matrix</li><li><code>b</code>: matrix</li></ul><p><em>Optional:</em></p><ul><li><code>type</code>: data type of model, either <code>Real</code> or <code>Complex</code></li><li><code>estimd</code>: if set to <code>false</code> no d matrix is esimated and a zero d matrix is returned</li></ul><p>Returns :</p><ul><li><code>c</code>: LS-optimal <code>c</code> matrix</li><li><code>d</code>: LS-optimal <code>d</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/estimate_c.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fdestim_bd-Tuple{AbstractArray{var&quot;#s39&quot;,1} where var&quot;#s39&quot;&lt;:Number,AbstractArray{var&quot;#s38&quot;,2} where var&quot;#s38&quot;&lt;:Number,AbstractArray{var&quot;#s37&quot;,2} where var&quot;#s37&quot;&lt;:Number,AbstractArray{var&quot;#s36&quot;,2} where var&quot;#s36&quot;&lt;:Number,AbstractArray{var&quot;#s35&quot;,2} where var&quot;#s35&quot;&lt;:Number}" href="#fsid.fdestim_bd-Tuple{AbstractArray{var&quot;#s39&quot;,1} where var&quot;#s39&quot;&lt;:Number,AbstractArray{var&quot;#s38&quot;,2} where var&quot;#s38&quot;&lt;:Number,AbstractArray{var&quot;#s37&quot;,2} where var&quot;#s37&quot;&lt;:Number,AbstractArray{var&quot;#s36&quot;,2} where var&quot;#s36&quot;&lt;:Number,AbstractArray{var&quot;#s35&quot;,2} where var&quot;#s35&quot;&lt;:Number}"><code>fsid.fdestim_bd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdestim_bd(
    z::AbstractVector{&lt;:Number},
    yd::AbstractMatrix{&lt;:Number},
    ud::AbstractMatrix{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    c::AbstractMatrix{&lt;:Number};
    estTrans::Bool = false,
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true
)</code></pre><p>Estimate <code>b</code> and <code>d</code> matrices (and optionally <code>xt</code>) given <code>yd</code>, <code>ud</code>, <code>a</code> and <code>c</code> matrices.</p><p>Calulates the <code>b</code> and <code>d</code> matrices (and optimally <code>xt</code>) for a linear dynamic system in state-space form given the <code>a</code> and <code>c</code> matrices and samples of frequency domain function data. It solves  if <code>estimd = true</code> and <code>estTrans = true</code></p><p><span>$\min_{b,d,xt} \sum_i \| ([d 0] + c*inv(z[i]*I-a)*[b xt])[ud[i,:]; z[i]]  - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>estimd = false</code> and <code>estTrans = true</code></p><p><span>$\min_{b,xt} \sum_i \| (c*inv(z[i]*I-a)*[b xt])[ud[i,:]; w[i]]  - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>estimd = true</code> and <code>estTrans = false</code></p><p><span>$\min_{b,d} \sum_i  \| (d+ c*inv(z[i]*I-a)*b)ud[i,:]  - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>estimd = false</code> and <code>estTrans = false</code></p><p><span>$\min_{b} \sum_i \| (c*inv(z[i]*I-a)*b)ud[i,:]  - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>type = Real</code> a real valued solution is calulated. if <code>type = Complex</code>  the solution is complex valued</p><p>Parameters:</p><ul><li><code>z</code>: vector with the samples of the function argument where <code>z[i]</code> is argument for index <code>i</code></li><li><code>yd</code>: output frequency data <code>yd[i,:]</code></li><li><code>ud</code>: input frequency data <code>ud[widx,:]</code></li><li><code>a</code>: system matrix</li><li><code>c</code>: output matrix</li></ul><p><em>Optional:</em></p><ul><li><code>estTrans</code>: if set to true also an xt vector will be estimated capturing the transient effect</li><li><code>type</code>: data type of model, either Real or Complex</li><li><code>estimd</code>: if set to false no <code>d</code> matrix is esimated and a zero <code>d</code> matrix is returned</li></ul><p>Returns:</p><ul><li><code>b</code>: the LS-optimal <code>b</code> matrix</li><li><code>d</code>: LS-optimal <code>d</code> matrix  zeros matrix if <code>estimd = false</code></li><li><code>xt</code>: LS-optimal <code>xt</code> vector if <code>estTrans = true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/estimate_d.jl#L92-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fdestim_cd" href="#fsid.fdestim_cd"><code>fsid.fdestim_cd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fdestim_cd(
    z::AbstractVector{&lt;:Number},
    yd::AbstractArray{&lt;:Number},
    ud::AbstractArray{&lt;:Number},
    a::AbstractArray{&lt;:Number},
    b::AbstractArray{&lt;:Number},
    xt::Union{AbstractVector{&lt;:Number}, Number} = 0;
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true
)</code></pre><p>Estimate <code>c</code> and <code>d</code> matrices given <code>z</code>, <code>yd</code>, <code>ud</code> and <code>a</code>, <code>c</code>, and (optionally <code>xt</code>) matrices.</p><p>Calulates the <code>c</code> and <code>d</code> matrices for a linear dynamic system on state-space form given the <code>a</code> and <code>b</code> matrices and samples of rational function data. It solves if <code>estimd = true</code></p><p><span>$\min_{c,d} \sum_i \| ([d 0] + c*inv(z[i]*I-a)*[b xt])[ud[i,:]; z[i]]  - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>estimd = false</code></p><p><span>$\min_{c} \sum_i \| (c*inv(z[i]*I-a)*[b xt])[ud[i,:]; w[i]]  - ffdata[i,:,:] \|^2_F$</span></p><p>if <code>type = Real</code> a real valued solution is calulated. if <code>type = Complex</code> the solution is complex valued</p><p>Parameters:</p><ul><li><code>ffdata</code>: data packed in a matrix. <code>ffdata[i,:,:]</code> is the frequency function matrix (sample of the rationl function) corresponding to sample <code>i</code></li><li><code>w</code>: vector with the rational function arguments. <code>w[i]</code> is the function arguemnt for sample <code>i</code></li><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li></ul><p><em>Optional:</em></p><ul><li><code>xt</code>: vector</li><li><code>type</code>: data type of model either <code>Real</code> or <code>Complex</code></li><li><code>estimd</code>: if set to false no d matrix is esimated and a zero d matrix is returned</li></ul><p>Returns :</p><ul><li><code>c</code>: LS-optimal c matrix</li><li><code>d</code>: LS-optimal d matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/estimate_d.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fdsid-Tuple{Tuple,Integer,Integer}" href="#fsid.fdsid-Tuple{Tuple,Integer,Integer}"><code>fsid.fdsid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function fdsid(
    fddata::Tuple,
    n::Integer,
    q::Integer;
    estTrans::Bool = true,
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true,
    CT::Bool = false,
    T::Real = 1
)</code></pre><p>Estimate a DT or CT state-space model from I/O frequency data.</p><p>Determines the <code>(a,b,c,d,xt)</code> parametrers such that (DT case)</p><p><span>$sum_i   || y[i,:] - d*u[i, :] + c*inv(z[i]*eye(n)-a)*[b,  xt]* [u[i, :]; z[i]]||^_F$</span></p><p>is small where <code>z[i] = exp(im*w[i])</code> and CT Case</p><p><span>$sum_i   ||  y[i,:] - d*u[i, :] + c*inv(im*w[i]*eye(n)-a)*b* u[i, :] ||^2_F$</span></p><p>Parameters:</p><ul><li><code>fddata</code>: a tuple with elements <ul><li><code>fddata[0] = w</code>: a vector of frequencies in radians/sample (rad/s in CT case)</li><li><code>fddata[1] = y</code>: a matrix of the output transform data where <code>y[i,:]</code> is the DFT of the time domain output signal corresponding to frequency <code>w[i]</code></li><li><code>fddata[2] = u</code>: a matrix of the input transform data where <code>u[i,:]</code> is the DFT of the time domain input signal corresponding to frequency <code>w[i]</code></li></ul></li><li><code>n</code>: the model order of the ss-model</li><li><code>q</code>: the numer of block rows used in the intermediate matrix. Must satisfy <code>q &gt; n</code></li></ul><p><em>Optional:</em></p><ul><li><code>estTrans</code>: if <code>true</code>, a compensation for the transient term will be estimated (default)</li><li><code>type</code>:<ul><li>if <code>type = Real</code> a real valued solution <code>(a, b, c, d)</code> is returned.</li><li>if <code>type = Complex</code> a complex valued solution is returned.</li></ul></li><li><code>estimd</code>: if set to <code>false</code> no <code>d</code> matrix is esimated and a zero <code>d</code> matrix is returned</li><li><code>CT</code>: if <code>true</code> a CT model is estimated and <code>estTrans</code> is forced <code>false</code></li><li><code>T</code>: a frequency scaling factor for the bilinear transformation used when <code>CT = true</code>.  Default is 1. If <code>CT = false</code> parameter <code>T</code> is disregarded</li></ul><p>Returns:</p><ul><li><code>a</code>: the estimated <code>a</code> matrix</li><li><code>b</code>: the estimated <code>b</code> matrix</li><li><code>c</code>: the estimated <code>c</code> matrix</li><li><code>d</code>: the estimated <code>d</code> matrix (or zero matrix if <code>estimd = false</code>)</li><li><code>xt</code>: vector of the transient compensation</li><li><code>s</code>: a vector of the singular values   </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/n4sid.jl#L166-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fdsim" href="#fsid.fdsim"><code>fsid.fdsim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function fdsim(
    sys::Tuple,
    u::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number},
    xt::AbstractMatrix{&lt;:Number} = Matrix{Float64}(undef, 0, 0)
)</code></pre><p>Calculates the output given input and state-space model in Fourier domain</p><p><span>$x[i,:] = inv(z[i]*I-a)*[B xt]*[u[i,:]; z[i]]$</span></p><p><span>$y[i,:] = d*u[i,:] + c*x[i,:]$</span></p><p>Parameters:</p><ul><li><code>sys</code>: typle <code>sys = (a, b, c, d)</code> or <code>sys = (a, b, c)</code> where <code>a</code> is a  square matrix of size (n,n), <code>b</code> is  a matrix of size (n, m), <code>c</code> is a matrix of size (p, n) and (optionally) <code>d</code> is a matrix of size (p, m).</li><li><code>u</code>: an array of input vectors such that <code>u[i,:]</code> is the input vector of size m at sample index <code>i</code>. The array has size (N, m)</li><li><code>z</code>: vector with the samples of the frequency function argument<br/></li><li><code>xt</code>: transient vector of size n, Default value is the zero vector. </li></ul><p>Returns:</p><ul><li><code>y</code>: the resulting output sequence of size (N,p)</li><li><code>x</code>: the resulting state sequence of size (N,p)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L504-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ffdata2fddata-Tuple{AbstractArray{var&quot;#s64&quot;,3} where var&quot;#s64&quot;&lt;:Number,AbstractArray{var&quot;#s63&quot;,1} where var&quot;#s63&quot;&lt;:Number}" href="#fsid.ffdata2fddata-Tuple{AbstractArray{var&quot;#s64&quot;,3} where var&quot;#s64&quot;&lt;:Number,AbstractArray{var&quot;#s63&quot;,1} where var&quot;#s63&quot;&lt;:Number}"><code>fsid.ffdata2fddata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ffdata2fddata(ffdata::AbstractArray{&lt;:Number, 3}, z::AbstractVector{&lt;:Number})</code></pre><p>Converts <code>ffdata</code> to <code>fddata</code>.</p><p>Converts frequency function data <code>ffdata</code> to input/output data format <code>fddata</code>.</p><p>Parameters:</p><ul><li><code>ffdata</code>: frequency function data in the format such that <code>ffdata[i,:,:]</code> corresponds to the frequency function matrix of size <code>(p,m)</code> at frequency index <code>i</code> corresponding to function argument <code>z[i]</code> at a total number of samples <code>nz</code></li><li><code>z</code>: array with the corresponding frequency function argument of size <code>nz</code></li></ul><p>Returns:</p><ul><li><code>u</code>: Fourier transform of input of size <code>(m*nz, m)</code></li><li><code>y</code>: Fourier transform of output of size <code>(m*nz, p)</code></li><li><code>zn</code>: frequency function argument vector of length <code>m*nw</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L364-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ffsid-Tuple{AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:Number,AbstractArray{var&quot;#s48&quot;,3} where var&quot;#s48&quot;&lt;:Number,Integer,Integer}" href="#fsid.ffsid-Tuple{AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:Number,AbstractArray{var&quot;#s48&quot;,3} where var&quot;#s48&quot;&lt;:Number,Integer,Integer}"><code>fsid.ffsid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ffsid(
    w::AbstractVector{&lt;:Number},
    ffdata::AbstractArray{&lt;:Number, 3},
    n::Integer,
    q::Integer;
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true,
    CT::Bool = false,
    T::Real = 1
)</code></pre><p>Estimate a state-space model <code>(a, b, c, d)</code> from frequency function data.</p><p>Parameters:</p><ul><li><code>w</code>: vector of frequencies in rad/sample [-pi,pi] or [0, 2pi]. if <code>CT = true</code> unit in radians/s (-inf, +inf)</li><li><code>ffdata</code>: matrix of frequency function data. <code>ffdata[i,:,:]</code> is the frequency response matrix at frequency <code>w[i]</code></li><li><code>n</code>: the model order of the ss-model <code>(a, b, c, d)</code>, i.e. <code>a</code> is a size (<code>n</code> x <code>n</code>) matrix</li><li><code>q</code>: the numer of block rows used in the intermediate matrix. Must satisfy <code>q &gt; n</code></li></ul><p><em>Optional:</em></p><ul><li><code>type</code>:<ul><li>if <code>type = Real</code> a real valued solution <code>(a, b, c, d)</code> is returned</li><li>if <code>type = Complex</code> a complex valued solution <code>(a,b,c,d)</code> is returned</li></ul></li><li><code>estimd</code>: if set to False no <code>d</code> matrix is esimated and a zero <code>d</code> matrix is returned</li><li><code>CT</code>:<ul><li>if set to <code>true</code> a continuous time (CT) model is esimated</li><li>if set to <code>false</code> a discrete time (DT) model is esimated (default)</li></ul></li><li><code>T</code>: a frequency scaling factor for the bilinear transformation used when <code>CT = true</code>. Default is 1. If <code>CT = false</code> parameter <code>T</code> is disregarded</li></ul><p>Returns:</p><ul><li><code>a</code>: the estimated <code>a</code> matrix</li><li><code>b</code>: the estimated <code>b</code> matrix</li><li><code>c</code>: the estimated <code>c</code> matrix</li><li><code>d</code>: the estimated <code>d</code> matrix (or zero matrix if <code>estimd = false</code>)</li><li><code>s</code>: a vector of the singular values   </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/n4sid.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fresp" href="#fsid.fresp"><code>fsid.fresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function fresp(
    z::AbstractVector{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    c::AbstractMatrix{&lt;:Number},
    d::AbstractMatrix{&lt;:Number},
    noWarning::Bool = true
)</code></pre><p>Frequency response of ss-model <code>(a,b,c,d)</code> a rational matrix function</p><p><span>$fresp[i,:,:] = d+c*inv(z[i]*I-a)*b$</span></p><p><code>fresp[i,:,:]</code> is the function value of the rational matrix function evaluated at <code>z[i]</code></p><p>Parameters:</p><ul><li><code>z</code>: vector with samples of the function argument</li><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li><li><code>c</code>: matrix</li><li><code>d</code>: matrix</li><li><code>noWarning</code>: information message is suppressed if set to true</li></ul><p>Returns:</p><ul><li><code>frsp</code>: frequency response</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L72-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fresp_fast!-Tuple{AbstractArray{var&quot;#s60&quot;,3} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Number,AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Number,AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Number,AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Number,LinearAlgebra.Eigen}" href="#fsid.fresp_fast!-Tuple{AbstractArray{var&quot;#s60&quot;,3} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Number,AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Number,AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Number,AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Number,LinearAlgebra.Eigen}"><code>fsid.fresp_fast!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function fresp_fast!(
   frsp::AbstractArray{&lt;:Number, 3},
    z::AbstractVector{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    c::AbstractMatrix{&lt;:Number},
    d::AbstractMatrix{&lt;:Number},
    eig::Eigen
)</code></pre><p>Frequency response of ss-model <code>(a, b, c, d)</code> (fast version)</p><p><span>$fresp[i,:,:] = d+c*inv(I*z[i]-a)*b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L35-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.fresp_slow!-Tuple{AbstractArray{var&quot;#s61&quot;,3} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,1} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,2} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Number,AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Number,AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Number}" href="#fsid.fresp_slow!-Tuple{AbstractArray{var&quot;#s61&quot;,3} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,1} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,2} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Number,AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Number,AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Number}"><code>fsid.fresp_slow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function fresp_slow!(
    frsp::AbstractArray{&lt;:Number, 3},
    z::AbstractVector{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    c::AbstractMatrix{&lt;:Number},
    d::AbstractMatrix{&lt;:Number}
)</code></pre><p>Frequency response of state-space model <code>(a, b, c, d)</code> (slow version) calulated as</p><p><span>$fresp[i,:,:] = d + c * (I*z[i]-a)^{-1} * b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.gfdsid-Tuple{Tuple,Integer,Integer}" href="#fsid.gfdsid-Tuple{Tuple,Integer,Integer}"><code>fsid.gfdsid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function gfdsid(
    fddata::Tuple,
    n::Integer,
    q::Integer;
    estTrans::Bool = true,
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true
)</code></pre><p>Estimate a state-space model from I/O frequency data</p><p>Determines the <code>(a, b, c, d, xt)</code> parameters such that</p><p><span>$\sum_i \| y[i,:] - d*u[i, :] + c*inv(z[i]*eye(n)-a)*[b,  xt]* [u[i, :]; z[i]] \|^2_F$</span></p><p>is minimized.</p><p>If <code>estrTrans = false</code> the following problem is solved</p><p><span>$\sum_i \| y[i,:] - d*u[i, :] + c*inv(z[i]*eye(n)-a)*b * u[i, :] \|^2_F$</span></p><p>is minimized.</p><p>Parameters:</p><ul><li><code>fddata</code>: a tuple with elements <ul><li><code>fddata[0] = z</code>: a vector of complex scalars,</li><li><code>fddata[1] = y</code>: a matrix of the output frequency data where <code>y[i,:]</code> corresponds to <code>z[i]</code></li><li><code>fddata[2] = u</code>: a matrix of the input frrequency data where <code>u[i,:]</code> corresponding to <code>z[i]</code></li></ul></li><li><code>n</code>: the model order of the ss-model</li><li><code>q</code>: the numer of block rows used in the intermediate matrix. Must satisfy <code>q &gt; n</code></li></ul><p><em>Optional:</em></p><ul><li><code>estTrans</code>: if <code>true</code>, a compensation for the transient term will be estimated (default)</li><li><code>type</code>:<ul><li>if <code>type = Real</code> a real valued solution <code>(a, b, c, d)</code> is returned.</li><li>if <code>type = Complex</code> a complex valued solution is returned.</li></ul></li><li><code>estimd</code>: if set to &#39;false&#39; no <code>d</code> matrix is esimated and a zero <code>d</code> matrix is returned</li></ul><p>Returns:</p><ul><li><code>a</code>: the estimated <code>a</code> matrix</li><li><code>b</code>: the estimated <code>b</code> matrix</li><li><code>c</code>: the estimated <code>c</code> matrix</li><li><code>d</code>: the estimated <code>d</code> matrix (or zero matrix if <code>estimd = false</code>)</li><li><code>x</code>: vector of the transient compensation</li><li><code>s</code>: a vector of the singular values   </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/n4sid.jl#L251-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.gffsid-Tuple{AbstractArray{var&quot;#s47&quot;,1} where var&quot;#s47&quot;&lt;:Number,AbstractArray{var&quot;#s46&quot;,3} where var&quot;#s46&quot;&lt;:Number,Integer,Integer}" href="#fsid.gffsid-Tuple{AbstractArray{var&quot;#s47&quot;,1} where var&quot;#s47&quot;&lt;:Number,AbstractArray{var&quot;#s46&quot;,3} where var&quot;#s46&quot;&lt;:Number,Integer,Integer}"><code>fsid.gffsid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function gffsid(
    z::AbstractVector{&lt;:Number},
    ffdata::AbstractArray{&lt;:Number, 3},
    n::Integer,
    q::Integer;
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real,
    estimd::Bool = true
)</code></pre><p>Estimate a state-space model <code>(a, b, c, d)</code> from general frequency function data by mininizing the Frobenius norm </p><p><span>$\sum_i \| ffdata[i,:,:] - d - c*inv(z[i]*eye(n)-a)*b \|^2_F$</span></p><p>Parameters:</p><ul><li><code>z</code>: vector of complex numbers</li><li><code>ffdata</code>: matrix of frequency function data. <code>ffdata[i,:,:]</code> is the frequency response matrix at complex point <code>z[i]</code></li><li><code>n</code>: the model order of the ss-model <code>(a, b, c, d)</code>, i.e. a is a size (<code>n</code> x <code>n</code>) matrix</li><li><code>q</code>: the numer of block rows used in the intermediate matrix. Must satisfy <code>q &gt; n</code></li></ul><p><em>Optional:</em></p><ul><li><code>type</code>:<ul><li>if <code>type = Real</code> a real valued solution <code>(a, b, c, d)</code> is returned</li><li>if <code>type = Complex</code> a complex valued solution is returned</li></ul></li><li><code>estimd</code>: if set to <code>false</code> no <code>d</code> matrix is esimated and a zero <code>d</code> matrix is returned</li></ul><p>Returns:</p><ul><li><code>a</code>: the estimated <code>a</code> matrix</li><li><code>b</code>: the estimated <code>b</code> matrix</li><li><code>c</code>: the estimated <code>c</code> matrix</li><li><code>d</code>: the estimated <code>d</code> matrix (or zero matrix if <code>estimd = false</code>)</li><li><code>s</code>: a vector of the singular values   </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/n4sid.jl#L63-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.lsim" href="#fsid.lsim"><code>fsid.lsim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function lsim(
    sys::Tuple,
    u::AbstractMatrix{&lt;:Number},
    x0::Union{AbstractVector{&lt;:Number}, Number} = 0;
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real
)</code></pre><p>Calculates the time-domain output given input sequence and state-space model <code>sys = (a, b, c, d)</code></p><p><span>$x[i+1,:] = a*x[i,:]) + b*u[i,:]$</span></p><p><span>$y[i,:] =  c*x[i,:]) + d*u[i,:]$</span></p><p>Parameters:</p><ul><li><code>sys</code>: a typle <code>sys = (a, b, c, d)</code> or <code>sys = (a, b, c)</code> where <code>a</code> is a square matrix of size (n,n), <code>b</code> is a matrix of size (n,m), <code>c</code> is a matrix of size (p,n) and (optionally) <code>d</code> is a matrix of size <code>(p, m)</code>`</li><li><code>u</code>: an array of input vectors such that <code>u[i,:]</code> is the input vector of size m at time index <code>i</code>. The array has size <code>(N, m)</code></li></ul><p><em>Optional:</em></p><ul><li><code>x0</code>: intial vector of size n, i.e. <code>x[0,:] = x0</code>. Default value is the zero vector</li></ul><p>Returns:</p><ul><li><code>y</code>: the resulting output sequence of size (N, p)</li><li><code>x</code>: the resulting state sequence of size (N, n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L446-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.lsim" href="#fsid.lsim"><code>fsid.lsim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function lsim(
    sys::Tuple,
    u::AbstractMatrix{&lt;:Number},
    x0::Union{AbstractVector{&lt;:Number}, Number} = 0;
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real
)</code></pre><p>Calculates the time-domain output given input sequence and state-space model <code>sys = (a, b, c, d)</code></p><p><span>$x[i+1,:] = a*x[i,:]) + b*u[i,:]$</span></p><p><span>$y[i,:] =  c*x[i,:]) + d*u[i,:]$</span></p><p>Parameters:</p><ul><li><code>sys</code>: a typle <code>sys = (a, b, c, d)</code> or <code>sys = (a, b, c)</code> where <code>a</code> is a square matrix of size (n,n), <code>b</code> is a matrix of size (n,m), <code>c</code> is a matrix of size (p,n) and (optionally) <code>d</code> is a matrix of size (p,m)</li><li><code>u</code>: an array of input vectors such that <code>u[i,:]</code> is the input vector of size m at time index <code>i</code>. The array has size (N,m).</li></ul><p><em>Optional:</em></p><ul><li><code>x0</code>: intial vector of size n, i.e. <code>x[0,:] = x0</code>. Default value is the zero vector</li></ul><p>Returns:</p><ul><li><code>y</code>: the resulting output sequence of size (N, p)</li><li><code>x</code>: the resulting state sequence of size (N, n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L446-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifd" href="#fsid.ltifd"><code>fsid.ltifd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ltifd(
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    u::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number},
    noWarning::Bool = true
)</code></pre><p>Calculates the frequency kernel with input <code>u</code></p><p><span>$fkern[:, i] = inv(z[i]*I - a)*b*u[i, :]$</span></p><p>Parameters:</p><ul><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li><li><code>u</code>: input vectors</li><li><code>z</code>: vector with samples of the function argument</li><li><code>noWarning</code>: if true suppress information message</li></ul><p>Returns:</p><ul><li><code>fkern</code>: frequency kernel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L316-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifd_fast!-Tuple{AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,2} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Number,AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:Number,LinearAlgebra.Eigen}" href="#fsid.ltifd_fast!-Tuple{AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,2} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Number,AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:Number,LinearAlgebra.Eigen}"><code>fsid.ltifd_fast!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifd_fast!(
    fkern::AbstractMatrix{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    u::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number},
    eig::Eigen
)</code></pre><p>Calculates the frequency kernel with input <code>u</code> in place (fast version)</p><p><span>$fkern[:, i] = inv(z[i]*I - a)*b*u[i, :]$</span></p><p>Parameters:</p><ul><li><code>fkern</code>: frequency kernel</li><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li><li><code>u</code>: matrix with input vectors</li><li><code>z</code>: vector with the frequecy data</li><li><code>eig</code>: eigendecomposition of <code>a</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L272-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifd_slow!-Tuple{AbstractArray{var&quot;#s34&quot;,2} where var&quot;#s34&quot;&lt;:Number,AbstractArray{var&quot;#s33&quot;,2} where var&quot;#s33&quot;&lt;:Number,AbstractArray{var&quot;#s30&quot;,2} where var&quot;#s30&quot;&lt;:Number,AbstractArray{var&quot;#s29&quot;,2} where var&quot;#s29&quot;&lt;:Number,AbstractArray{var&quot;#s28&quot;,1} where var&quot;#s28&quot;&lt;:Number}" href="#fsid.ltifd_slow!-Tuple{AbstractArray{var&quot;#s34&quot;,2} where var&quot;#s34&quot;&lt;:Number,AbstractArray{var&quot;#s33&quot;,2} where var&quot;#s33&quot;&lt;:Number,AbstractArray{var&quot;#s30&quot;,2} where var&quot;#s30&quot;&lt;:Number,AbstractArray{var&quot;#s29&quot;,2} where var&quot;#s29&quot;&lt;:Number,AbstractArray{var&quot;#s28&quot;,1} where var&quot;#s28&quot;&lt;:Number}"><code>fsid.ltifd_slow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifd_slow!(
    fkern::AbstractMatrix{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    u::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number}
)</code></pre><p>Calculates the frequency kernel with input <code>u</code> in place (slow version)</p><p><span>$fkern[:, i] = inv(z[i]*I - a)*b*u[i, :]$</span></p><p>Parameters:</p><ul><li><code>fkern</code>: frequency kernel</li><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li><li><code>u</code>: matrix with input vectors</li><li><code>z</code>: vector with the frequecy data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L233-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifd_slow!-Tuple{AbstractArray{var&quot;#s62&quot;,2} where var&quot;#s62&quot;&lt;:Number,AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,2} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Number}" href="#fsid.ltifd_slow!-Tuple{AbstractArray{var&quot;#s62&quot;,2} where var&quot;#s62&quot;&lt;:Number,AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,2} where var&quot;#s59&quot;&lt;:Number,AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Number}"><code>fsid.ltifd_slow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifd_slow!(
    fkern::AbstractMatrix{&lt;:Number},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    u::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number}
)</code></pre><p>Calculates the frequency kernel with input <code>u</code> in place (slow version)</p><p><span>$fkern[:, i] = inv(z[i]*I - a)*b*u[i, :]$</span></p><p>Parameters:</p><ul><li><code>fkern</code>: frequency kernel</li><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li><li><code>u</code>: matrix with input vectors</li><li><code>z</code>: vector with the frequecy data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L233-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifr" href="#fsid.ltifr"><code>fsid.ltifr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ltifr(
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number},
    noWarning::Bool = true    
)</code></pre><p>Calculates the frequency kernel</p><p><span>$fkern[i,:,:] = inv(z[i]*I-a)*b$</span></p><p>Parameters:</p><ul><li><code>a</code>: matrix</li><li><code>b</code>: matrix</li><li><code>z</code>: vector with the samples of the function argument</li><li><code>noWarning</code>: if true suppress information message</li></ul><p>Returns:</p><ul><li><code>fkern</code>: frequency response </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L187-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifr_fast!-Tuple{AbstractArray{var&quot;#s34&quot;,3} where var&quot;#s34&quot;&lt;:Number,AbstractArray{var&quot;#s33&quot;,2} where var&quot;#s33&quot;&lt;:Number,AbstractArray{var&quot;#s30&quot;,2} where var&quot;#s30&quot;&lt;:Number,AbstractArray{var&quot;#s29&quot;,1} where var&quot;#s29&quot;&lt;:Number,LinearAlgebra.Eigen}" href="#fsid.ltifr_fast!-Tuple{AbstractArray{var&quot;#s34&quot;,3} where var&quot;#s34&quot;&lt;:Number,AbstractArray{var&quot;#s33&quot;,2} where var&quot;#s33&quot;&lt;:Number,AbstractArray{var&quot;#s30&quot;,2} where var&quot;#s30&quot;&lt;:Number,AbstractArray{var&quot;#s29&quot;,1} where var&quot;#s29&quot;&lt;:Number,LinearAlgebra.Eigen}"><code>fsid.ltifr_fast!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifr_fast!(
    fkern::AbstractArray{&lt;:Number, 3},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number},
    eig::Eigen
)</code></pre><p>Calculates the frequency kernel in place (fast version)</p><p><span>$fkern[i,:,:] = inv(z[i]*I-a)*b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L154-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifr_fast!-Tuple{AbstractArray{var&quot;#s62&quot;,3} where var&quot;#s62&quot;&lt;:Number,AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Number,LinearAlgebra.Eigen}" href="#fsid.ltifr_fast!-Tuple{AbstractArray{var&quot;#s62&quot;,3} where var&quot;#s62&quot;&lt;:Number,AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Number,LinearAlgebra.Eigen}"><code>fsid.ltifr_fast!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifr_fast!(
    fkern::AbstractArray{&lt;:Number, 3},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number},
    eig::Eigen
)</code></pre><p>Calculates the frequency kernel in place (fast version)</p><p><span>$fkern[i,:,:] = inv(z[i]*I-a)*b (slow version)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L154-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifr_slow!-Tuple{AbstractArray{var&quot;#s34&quot;,3} where var&quot;#s34&quot;&lt;:Number,AbstractArray{var&quot;#s33&quot;,2} where var&quot;#s33&quot;&lt;:Number,AbstractArray{var&quot;#s30&quot;,2} where var&quot;#s30&quot;&lt;:Number,AbstractArray{var&quot;#s29&quot;,1} where var&quot;#s29&quot;&lt;:Number}" href="#fsid.ltifr_slow!-Tuple{AbstractArray{var&quot;#s34&quot;,3} where var&quot;#s34&quot;&lt;:Number,AbstractArray{var&quot;#s33&quot;,2} where var&quot;#s33&quot;&lt;:Number,AbstractArray{var&quot;#s30&quot;,2} where var&quot;#s30&quot;&lt;:Number,AbstractArray{var&quot;#s29&quot;,1} where var&quot;#s29&quot;&lt;:Number}"><code>fsid.ltifr_slow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifr_slow!(
    fkern::AbstractArray{&lt;:Number, 3},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number}
)</code></pre><p>Calculates the frequency kernel in place as (slow version)</p><p><span>$fkern[i,:,:] = inv(z[i]*I-a)*b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L126-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltifr_slow!-Tuple{AbstractArray{var&quot;#s62&quot;,3} where var&quot;#s62&quot;&lt;:Number,AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Number}" href="#fsid.ltifr_slow!-Tuple{AbstractArray{var&quot;#s62&quot;,3} where var&quot;#s62&quot;&lt;:Number,AbstractArray{var&quot;#s61&quot;,2} where var&quot;#s61&quot;&lt;:Number,AbstractArray{var&quot;#s60&quot;,2} where var&quot;#s60&quot;&lt;:Number,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Number}"><code>fsid.ltifr_slow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ltifr_slow!(
    fkern::AbstractArray{&lt;:Number, 3},
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    z::AbstractVector{&lt;:Number}
)</code></pre><p>Calculates the frequency kernel in place as</p><p><span>$fkern[i,:,:] = inv(z[i]*I-a)*b (slow version)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L126-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.ltitr" href="#fsid.ltitr"><code>fsid.ltitr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ltitr(
    a::AbstractMatrix{&lt;:Number},
    b::AbstractMatrix{&lt;:Number},
    u::AbstractMatrix{&lt;:Number},
    x0::Union{AbstractVector{&lt;:Number}, Number} = 0;
    type::Union{Type{&lt;:Real}, Type{&lt;:Complex}} = Real
)</code></pre><p>Calculates the time domain input to state respone.</p><p>Calculates the time domain state response</p><p><span>$x[i+1,:] = a*x[i,:]) + b*u[i,:]$</span></p><p>Parmeters:</p><ul><li><code>a</code>: a square matrix of size <code>(n, n)</code></li><li><code>b</code>: a matrix of size <code>(n, m)</code></li><li><code>u</code>: an array of input vectors such that <code>u[i,:]</code> is the input vector of size <code>m</code> at time index <code>i</code>. The array has size <code>(N, m)</code></li><li><code>x0</code>: intial vector of size <code>n</code>, i.e. <code>x[0,:] = x0</code>. Default value is the zero vector</li></ul><p>Returns:</p><ul><li><code>x</code>: the resulting state-sequence of size <code>(N, n)</code></li><li><code>x[k,:]</code>: is the state at sample <code>k</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/misc.jl#L399-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.matrix_chain_order-Tuple{Any}" href="#fsid.matrix_chain_order-Tuple{Any}"><code>fsid.matrix_chain_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix_chain_order(p)</code></pre><p>Reference: Cormen, &quot;Introduction to Algorithms&quot;, Chapter 15.2, p. 370-378</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/math.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.multidot-Tuple" href="#fsid.multidot-Tuple"><code>fsid.multidot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multidot(mats...)</code></pre><p>Fast multiplication of multiple matrices, i.e. optimal order. Provide matrices in order of multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/math.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.optimal_print-Tuple{Any,Any,Any}" href="#fsid.optimal_print-Tuple{Any,Any,Any}"><code>fsid.optimal_print</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimal_print(s, i, j)</code></pre><p>Helper function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/math.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fsid.transpose_ffdata-Tuple{AbstractArray{var&quot;#s45&quot;,3} where var&quot;#s45&quot;&lt;:Number}" href="#fsid.transpose_ffdata-Tuple{AbstractArray{var&quot;#s45&quot;,3} where var&quot;#s45&quot;&lt;:Number}"><code>fsid.transpose_ffdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transpose_ffdata(ffdata::AbstractArray{&lt;:Number, 3})</code></pre><p>Transposes ffdata (changes inputs and outputs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgcth/fsid/blob/9b71977e6a8c9007a1c44583c93f00abf643a06c/julia/src/estimate_c.jl#L117-L121">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 30 December 2020 15:35">Wednesday 30 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
